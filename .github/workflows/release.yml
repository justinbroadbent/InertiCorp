name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --configuration Release --no-restore

      - name: Test
        run: dotnet test --configuration Release --no-build --verbosity normal

  build-windows:
    name: Build Windows Release
    needs: test
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Setup Godot
        uses: chickensoft-games/setup-godot@v2
        with:
          version: 4.5.1
          use-dotnet: true
          include-templates: true

      - name: Restore dependencies
        run: dotnet restore

      - name: Verify Godot setup
        run: |
          echo "GODOT: $GODOT"
          echo "Godot version:"
          "$GODOT" --version
        shell: bash

      - name: Download cuBLAS DLLs
        run: |
          # Download CUDA runtime DLLs from llama.cpp release (required for GPU matrix operations)
          # NOTE: cuBLAS is in a SEPARATE package (cudart-llama-*) from the main llama binary
          # We use NuGet LLamaSharp.Backend.Cuda12 for llama/ggml DLLs (compatible with LLamaSharp)
          $cudartUrl = "https://github.com/ggml-org/llama.cpp/releases/download/b7616/cudart-llama-bin-win-cuda-12.4-x64.zip"
          $cudartZip = "cudart.zip"

          Write-Host "Downloading CUDA runtime DLLs (cuBLAS) from llama.cpp..."
          Invoke-WebRequest -Uri $cudartUrl -OutFile $cudartZip -TimeoutSec 600

          $cudartDir = "cudart-extracted"
          Expand-Archive -Path $cudartZip -DestinationPath $cudartDir -Force

          # List what we got
          Write-Host "Extracted contents:"
          Get-ChildItem $cudartDir -Recurse -Filter "*.dll" | ForEach-Object { Write-Host "  $($_.FullName)" }

          # Create target directory for cuBLAS
          $targetDir = "src/InertiCorp.Core/native/cuda12"
          New-Item -ItemType Directory -Force -Path $targetDir

          # Copy cuBLAS DLLs (NOT llama.dll/ggml*.dll - those come from NuGet)
          $cublasDlls = @("cublas64_12.dll", "cublasLt64_12.dll", "cudart64_12.dll")
          foreach ($dll in $cublasDlls) {
            $srcFile = Get-ChildItem $cudartDir -Filter $dll -Recurse | Select-Object -First 1
            if ($srcFile) {
              Copy-Item $srcFile.FullName $targetDir -Force
              Write-Host "Copied $dll ($([math]::Round($srcFile.Length / 1MB, 1)) MB)"
            } else {
              Write-Host "ERROR: $dll not found in cudart package!"
            }
          }

          Write-Host ""
          Write-Host "cuBLAS DLLs ready:"
          Get-ChildItem $targetDir | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 1)) MB)" }
        shell: pwsh

      - name: Generate .NET bindings
        run: |
          "$GODOT" --headless --path src/InertiCorp.Game --build-solutions --quit || true
        shell: bash

      - name: Build .NET project
        run: dotnet build --configuration Release

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
        shell: bash

      - name: Create build directory
        run: New-Item -ItemType Directory -Force -Path build
        shell: pwsh

      - name: Export Game
        run: |
          echo "Exporting to: ${{ github.workspace }}/build/InertiCorp.exe"
          "$GODOT" --headless --verbose --path src/InertiCorp.Game --export-release "Windows Desktop" "${{ github.workspace }}/build/InertiCorp.exe"
        shell: bash

      - name: Copy .NET assemblies to build
        run: |
          $dataDir = "build\data_InertiCorp.Game_windows_x86_64"
          New-Item -ItemType Directory -Force -Path $dataDir

          # The ExportRelease directory contains win-x64 subdirectory with all assemblies
          # Copy the contents of win-x64 directly to the data directory (not the win-x64 folder itself)
          $exportDir = "src\InertiCorp.Game\.godot\mono\temp\bin\ExportRelease\win-x64"
          if (Test-Path $exportDir) {
            Copy-Item "$exportDir\*" $dataDir -Recurse -Force
            Write-Host "Copied assemblies from: $exportDir"
          } else {
            Write-Host "ExportRelease\win-x64 not found, checking other locations..."

            # Fallback to Release directory
            $monoDir = "src\InertiCorp.Game\.godot\mono\temp\bin\Release"
            if (Test-Path $monoDir) {
              Copy-Item "$monoDir\*" $dataDir -Recurse -Force
              Write-Host "Copied assemblies from: $monoDir"
            }
          }

          Write-Host "Data directory file count:"
          (Get-ChildItem $dataDir -File).Count
          Write-Host "Sample files:"
          Get-ChildItem $dataDir -File | Select-Object -First 10 Name
        shell: pwsh

      - name: Setup LLM native runtimes from NuGet
        run: |
          $ErrorActionPreference = "Stop"
          $dataDir = "build\data_InertiCorp.Game_windows_x86_64"
          $runtimesDir = "$dataDir\runtimes\win-x64\native"
          $nugetBase = "$env:USERPROFILE\.nuget\packages"

          # Create directories
          New-Item -ItemType Directory -Force -Path "$runtimesDir\cuda12" | Out-Null
          New-Item -ItemType Directory -Force -Path "$runtimesDir\avx2" | Out-Null

          # Remove any DLLs that ended up in wrong places
          $nativeDlls = @("llama.dll", "ggml.dll", "ggml-base.dll", "ggml-cpu.dll", "ggml-cuda.dll", "mtmd.dll")
          foreach ($dll in $nativeDlls) {
            $wrongPath = "$dataDir\$dll"
            if (Test-Path $wrongPath) {
              Remove-Item $wrongPath -Force
              Write-Host "Removed $dll from data root"
            }
          }

          # === COPY CPU BACKEND (avx2) FROM NUGET ===
          $cpuSrc = "$nugetBase\llamasharp.backend.cpu\0.25.0\runtimes\win-x64\native\avx2"
          if (-not (Test-Path $cpuSrc)) {
            Write-Error "FATAL: CPU backend not found at $cpuSrc"
            exit 1
          }
          Copy-Item "$cpuSrc\*" "$runtimesDir\avx2" -Force
          Write-Host "Copied CPU backend (avx2) from NuGet"

          # === COPY CUDA BACKEND FROM NUGET ===
          $cudaSrcPaths = @(
            "$nugetBase\llamasharp.backend.cuda12.windows\0.25.0\runtimes\win-x64\native\cuda12",
            "$nugetBase\llamasharp.backend.cuda12\0.25.0\runtimes\win-x64\native\cuda12"
          )
          $cudaSrc = $cudaSrcPaths | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $cudaSrc) {
            Write-Host "Available LLamaSharp packages:"
            Get-ChildItem "$nugetBase\llamasharp*" -Directory | ForEach-Object { Write-Host "  $($_.Name)" }
            Write-Error "FATAL: CUDA12 backend not found"
            exit 1
          }
          Copy-Item "$cudaSrc\*" "$runtimesDir\cuda12" -Force
          Write-Host "Copied CUDA12 backend from: $cudaSrc"

          # === COPY ggml-cpu.dll TO cuda12 (required dependency) ===
          Copy-Item "$runtimesDir\avx2\ggml-cpu.dll" "$runtimesDir\cuda12" -Force
          Write-Host "Copied ggml-cpu.dll to cuda12"

          # === COPY cuBLAS DLLs (NuGet doesn't include these) ===
          $sourceDir = "src/InertiCorp.Core/native/cuda12"
          $cublasDlls = @("cublas64_12.dll", "cublasLt64_12.dll", "cudart64_12.dll")
          foreach ($dll in $cublasDlls) {
            $srcPath = "$sourceDir\$dll"
            if (-not (Test-Path $srcPath)) {
              Write-Error "FATAL: $dll not found in $sourceDir"
              exit 1
            }
            Copy-Item $srcPath "$runtimesDir\cuda12" -Force
            Write-Host "Copied $dll to cuda12"
          }

          Write-Host "`n=== avx2 contents ==="
          Get-ChildItem "$runtimesDir\avx2" | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 1)) MB)" }
          Write-Host "`n=== cuda12 contents ==="
          Get-ChildItem "$runtimesDir\cuda12" | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 1)) MB)" }
        shell: pwsh

      - name: Verify all required DLLs are present
        run: |
          $ErrorActionPreference = "Stop"
          $runtimesDir = "build\data_InertiCorp.Game_windows_x86_64\runtimes\win-x64\native"

          Write-Host "=== Verifying required DLLs ==="
          $failed = $false

          # === CHECK cuda12 (GPU backend) ===
          Write-Host "`n--- cuda12 (GPU) ---"
          $cuda12Required = @(
            @{Name="llama.dll"; MinMB=1},
            @{Name="ggml.dll"; MinMB=0},
            @{Name="ggml-base.dll"; MinMB=0},
            @{Name="ggml-cpu.dll"; MinMB=0.5},
            @{Name="ggml-cuda.dll"; MinMB=100},
            @{Name="cublas64_12.dll"; MinMB=50},
            @{Name="cublasLt64_12.dll"; MinMB=200},
            @{Name="cudart64_12.dll"; MinMB=0}
          )
          foreach ($dll in $cuda12Required) {
            $path = "$runtimesDir\cuda12\$($dll.Name)"
            if (Test-Path $path) {
              $sizeMB = [math]::Round((Get-Item $path).Length / 1MB, 1)
              if ($sizeMB -lt $dll.MinMB) {
                Write-Host "[FAIL] cuda12/$($dll.Name) is $sizeMB MB (expected >= $($dll.MinMB) MB)"
                $failed = $true
              } else {
                Write-Host "[OK] cuda12/$($dll.Name) ($sizeMB MB)"
              }
            } else {
              Write-Host "[MISSING] cuda12/$($dll.Name)"
              $failed = $true
            }
          }

          # === CHECK avx2 (CPU backend) ===
          Write-Host "`n--- avx2 (CPU) ---"
          $avx2Required = @(
            @{Name="llama.dll"; MinMB=1},
            @{Name="ggml.dll"; MinMB=0},
            @{Name="ggml-base.dll"; MinMB=0},
            @{Name="ggml-cpu.dll"; MinMB=0.5}
          )
          foreach ($dll in $avx2Required) {
            $path = "$runtimesDir\avx2\$($dll.Name)"
            if (Test-Path $path) {
              $sizeMB = [math]::Round((Get-Item $path).Length / 1MB, 1)
              if ($sizeMB -lt $dll.MinMB) {
                Write-Host "[FAIL] avx2/$($dll.Name) is $sizeMB MB (expected >= $($dll.MinMB) MB)"
                $failed = $true
              } else {
                Write-Host "[OK] avx2/$($dll.Name) ($sizeMB MB)"
              }
            } else {
              Write-Host "[MISSING] avx2/$($dll.Name)"
              $failed = $true
            }
          }

          if ($failed) {
            Write-Error "BUILD FAILED: Missing or undersized DLLs detected"
            exit 1
          }

          Write-Host "`n=== All DLLs verified ==="
        shell: pwsh

      - name: List build directory
        run: ls -laR build/
        shell: bash

      - name: Verify export succeeded
        run: |
          if [ ! -f "build/InertiCorp.exe" ]; then
            echo "Export failed - InertiCorp.exe not found"
            exit 1
          fi
          echo "Export succeeded! File count:"
          find build -type f | wc -l
        shell: bash

      - name: Create ZIP archive
        run: |
          Compress-Archive -Path build\* -DestinationPath "InertiCorp-${{ steps.version.outputs.VERSION }}-Windows.zip"
        shell: pwsh

      - name: Install Inno Setup
        run: choco install innosetup -y

      - name: Update version in installer script
        run: |
          $content = Get-Content installer/InertiCorp.iss -Raw
          $content = $content -replace '#define MyAppVersion ".*"', '#define MyAppVersion "${{ steps.version.outputs.VERSION }}"'
          Set-Content installer/InertiCorp.iss $content
        shell: pwsh

      - name: Build Installer
        run: |
          # Update source path to use absolute path
          $issContent = Get-Content installer/InertiCorp.iss -Raw
          $issContent = $issContent -replace 'Source: "\.\.\\build\\\*"', "Source: `"${{ github.workspace }}\build\*`""
          Set-Content installer/InertiCorp.iss $issContent
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" /O"." /F"InertiCorp-${{ steps.version.outputs.VERSION }}-Setup" installer/InertiCorp.iss
        shell: pwsh

      - name: Upload Release Assets
        uses: softprops/action-gh-release@v1
        with:
          files: |
            InertiCorp-${{ steps.version.outputs.VERSION }}-Windows.zip
            InertiCorp-${{ steps.version.outputs.VERSION }}-Setup.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-linux:
    name: Build Linux Release
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Setup Godot
        uses: chickensoft-games/setup-godot@v2
        with:
          version: 4.5.1
          use-dotnet: true
          include-templates: true

      - name: Restore dependencies
        run: dotnet restore

      - name: Generate .NET bindings
        run: godot --headless --path src/InertiCorp.Game --build-solutions --quit || true

      - name: Build .NET project
        run: dotnet build --configuration Release

      - name: Create build directory
        run: mkdir -p build

      - name: Export Game
        run: godot --headless --path src/InertiCorp.Game --export-release "Linux" "../../build/InertiCorp.x86_64"

      - name: Copy .NET assemblies to build
        run: |
          DATA_DIR="build/data_InertiCorp.Game_linuxbsd_x86_64"
          mkdir -p "$DATA_DIR"

          # The ExportRelease directory contains linux-x64 subdirectory with all assemblies
          # Copy the contents directly (not the linux-x64 folder itself)
          EXPORT_DIR="src/InertiCorp.Game/.godot/mono/temp/bin/ExportRelease/linux-x64"
          if [ -d "$EXPORT_DIR" ]; then
            cp -r "$EXPORT_DIR"/* "$DATA_DIR/"
            echo "Copied assemblies from: $EXPORT_DIR"
          else
            echo "ExportRelease/linux-x64 not found, checking other locations..."

            # Fallback to Release directory
            MONO_DIR="src/InertiCorp.Game/.godot/mono/temp/bin/Release"
            if [ -d "$MONO_DIR" ]; then
              cp -r "$MONO_DIR"/* "$DATA_DIR/" || true
              echo "Copied assemblies from: $MONO_DIR"
            fi
          fi

          echo "Data directory file count:"
          ls -1 "$DATA_DIR" | wc -l
          echo "Sample files:"
          ls "$DATA_DIR" | head -10

      - name: Get version from tag
        id: version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create tarball
        run: |
          cd build
          tar -czvf "../InertiCorp-${{ steps.version.outputs.VERSION }}-Linux.tar.gz" *

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v1
        with:
          files: InertiCorp-${{ steps.version.outputs.VERSION }}-Linux.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
